#define _XOPEN_SOURCE   700             // needed for dprintf

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>

#define REG_PORT_MIN    1024            // lowest registered port
#define DEFAULT_PATH    "temp.nasm"

typedef enum {eax, ebx, ecx, edx} reg32_t;

int temp_fd;

const char * header = "; Generated by <whatever I call this>\n\n"
                        "global _start\n\n"
                        "section .text\n"
                        "_start:\n\n";

/* Helper functions */
static char * enum2reg32(reg32_t register);
static char * enum2reg16(reg32_t register);
static char * enum2reg8lo(reg32_t register);
char * enum2reg8hi(reg32_t register);  

static void store_in_reg(uint32_t value, reg32_t register);

/* To write "recipes" for bind shell, reverse shell, etc. */
static void build_syscall3(uint16_t syscall, uint32_t arg_ebx, uint32_t arg_ecx,
    uint32_t arg_edx); 

char * enum2reg8hi(reg32_t register)
{
    char * reg_name;

    switch(register)
    {
        case eax:
            reg_name = "ah";
            break;
        case ebx:
            reg_name = "bh";
            break;
        case ecx:
            reg_name = "ch";
            break;
        case edx:
            reg_name = "dh";
            break;
        default:
            reg_name = "ERR";
            fprintf("[-] Unsupported register #%d\n", register);
    }

    return reg_name;
}

static char * enum2reg8lo(reg32_t register)
{
    char * reg_name;

    switch(register)
    {
        case eax:
            reg_name = "al";
            break;
        case ebx:
            reg_name = "bl";
            break;
        case ecx:
            reg_name = "cl";
            break;
        case edx:
            reg_name = "dl";
            break;
        default:
            reg_name = "ERR";
            fprintf("[-] Unsupported register #%d\n", register);
    }

    return reg_name;
}

static char * enum2reg16(reg32_t register)
{
    char * reg_name;

    switch(register)
    {
        case eax:
            reg_name = "ax";
            break;
        case ebx:
            reg_name = "bx";
            break;
        case ecx:
            reg_name = "cx";
            break;
        case edx:
            reg_name = "dx";
            break;
        default:
            reg_name = "ERR";
            fprintf("[-] Unsupported register #%d\n", register);
    }

    return reg_name;
}

static char * enum2reg32(reg32_t register)
{
    char * reg_name;

    switch(register)
    {
        case eax:
            reg_name = "eax";
            break;
        case ebx:
            reg_name = "ebx";
            break;
        case ecx:
            reg_name = "ecx";
            break;
        case edx:
            reg_name = "edx";
            break;
        default:
            reg_name = "ERR";
            fprintf("[-] Unsupported register #%d\n", register);
    }

    return reg_name;
}

static void store_in_reg(uint32_t value, reg32_t register)
{
    if (value > UINT16_MAX)
    {
        // No need to zero it out first
    }
    else if (value <= UINT8_MAX)
    {
        dprintf(temp_fd, "\txor %s, %s\n", 
            enum2reg32(register), enum2reg32(register));  

        dprintf(temp_fd, "\tmov %s, %s\n",
            enum2reg8lo(register), atoi(value));  
    }
    else if (value <= UINT16_MAX)
    {

        dprintf(temp_fd, "\txor %s, %s\n", 
            enum2reg32(register), enum2reg32(register));    

        dprintf(temp_fd, "\t; TODO: handle 2-byte values\n");
    }
    else
    {
        dprintf(temp_fd, "\t; Unexpected error\n");
    }
}

static void build_syscall3(uint16_t syscall, uint32_t arg_ebx, uint32_t arg_ecx,
    uint32_t arg_edx)
{
    dprintf(temp_fd, "\t; Syscall %d: (%d, %d, %d)\n",
        syscall, arg_ebx, arg_ecx, arg_edx);

    store_in_reg(syscall, eax);
    store_in_reg(arg_ebx, ebx);
    store_in_reg(arg_ecx, ecx);
    store_in_reg(arg_edx, edx);
    
    dprintf(temp_fd, "\tint 0x80\n"); 
} 

int main(int argc, char * argv[])
{
    uint16_t port;
    ssize_t written;

    if (argc < 2)
    {
        printf("Usage: %s <port number>\n"
            "\tE.g. %s 1337\n", argv[0], argv[0]);

        return EXIT_FAILURE;
    }
    else
    {
        port = atoi(argv[1]);
    }
    
    printf("[!] Generating bind shell on port %d\n", port);
    
    if (0 == port)
    {
        printf("[!] Port 0? Living dangerously, eh.\n");
    }
    if (port < REG_PORT_MIN)
    {
        printf("[!] You may need root to bind to a port below %d\n",
            REG_PORT_MIN);
    }    

    temp_fd = open(DEFAULT_PATH, O_WRONLY | O_CREAT, S_IRWXU);

    if (temp_fd < 0)
    {
        perror("open()");
        return EXIT_FAILURE;
    }

    written = write(temp_fd, header, strlen(header));

    // socket(AF_INET, SOCK_STREAM, 0)
    build_syscall3(SYS_socket, AF_INET, SOCK_STREAM, 0);

    if (close(temp_fd))
    {
        perror("close()");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
