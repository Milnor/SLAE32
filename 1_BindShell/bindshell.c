#define _XOPEN_SOURCE   700             // needed for dprintf

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/stat.h>

#define REG_PORT_MIN    1024            // lowest registered port
#define DEFAULT_PATH    "temp.nasm"

int temp_fd;

const char * header = "; Generated by <whatever I call this>\n\n"
                        "global _start\n\n"
                        "section .text\n"
                        "_start:\n\n";

void build_syscall3(uint16_t syscall, uint32_t arg_ebx, uint32_t arg_ecx,
    uint32_t arg_edx); 


void build_syscall3(uint16_t syscall, uint32_t arg_ebx, uint32_t arg_ecx,
    uint32_t arg_edx)
{
    dprintf(temp_fd, "; TODO: %d, %d, %d, %d\n",
        syscall, arg_ebx, arg_ecx, arg_edx);
} 

int main(int argc, char * argv[])
{
    uint16_t port;
    ssize_t written;

    // TODO: add support for user specified IP address
    if (argc < 2)
    {
        printf("Usage: %s <port number> [IP address]\n"
            "\tE.g. %s 1337\n"
            "\tE.G. %s 8888 192.168.0.5\n",
            argv[0], argv[0], argv[0]);

        return EXIT_FAILURE;
    }
    else
    {
        port = atoi(argv[1]);
    }
    
    printf("[!] Generating bind shell on port %d\n", port);
    
    if (port < REG_PORT_MIN)
    {
        printf("[!] You may need root to bind to a port below %d\n",
            REG_PORT_MIN);
    }    

    temp_fd = open(DEFAULT_PATH, O_WRONLY | O_CREAT, S_IRWXU);

    if (temp_fd < 0)
    {
        perror("open()");
        return EXIT_FAILURE;
    }

    written = write(temp_fd, header, strlen(header));

    // socket(AF_INET, SOCK_STREAM, 0)
    build_syscall3(SYS_socket, AF_INET, SOCK_STREAM, 0);

    if (close(temp_fd))
    {
        perror("close()");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
